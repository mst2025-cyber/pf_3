<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>クリック展開式マインドマップ (ルートのみ初期表示)</title>
<style>
    body {
        margin: 0;
        overflow: auto;
        background: #fafafa;
        font-family: 'Inter', sans-serif;
    }

    text {
        font-size: 14px;
        fill: #333;
        cursor: pointer;
        user-select: none;
        pointer-events: none;
    }

    rect {
        fill: #fff;
        stroke: #4A90E2;
        stroke-width: 2px;
        cursor: pointer;
        transition: all 0.5s;
    }

    .node--internal rect {
        fill: #e6f2ff;
        stroke: #4A90E2;
    }

    .node--root rect {
        fill: #4A90E2;
        stroke: #1C5B9E;
    }
    .node--root text {
        fill: #fff;
        font-weight: bold;
    }

    /* リンクを持つノードのテキストスタイル */
    .node--link text {
        fill: #0066cc;
        text-decoration: underline;
    }
    /* リンクを持つノードの矩形スタイル */
    .node--link rect {
        stroke: #0066cc;
        fill: #f0f8ff;
    }

    .link {
        fill: none;
        stroke: #bbb;
        stroke-width: 2px;
        transition: stroke 0.5s;
    }
</style>
</head>
<body>

<!-- ▼ D3.js（CDN） -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script>
//------------------------------------
// マインドマップデータ
//------------------------------------
const treeData = {
    name: "Masato's Mindmap",
    children: [
        {
            name: "生成AI初級ゼミ",
            children: [
                { name: "面白画像の生成" },
                { name: "面白動画の生成" },
                { name: "AIを利用した絵本の作成" },
                { name: "動画生成AIを使う" }
            ]
        },
        {
            name: "生成AI中級ゼミ",
            children: [
                { name: "バイブコーディングによるアプリ開発"},    
                { name: "difyハンズオンセミナー",
                    children: [                
                        { name: "第1回：Dify導入と環境構築" },
                        { name: "第2回：LLMノードとプロンプト設計" },
                        { name: "第3回：Knowledge（RAG）とドキュメント連携"},
                        { name: "第4回：エージェントと外部連携" },
                        { name: "第5回：デプロイ・運用・発表" }
                    ]
                }
            ]
        },
        {
            name: "プロンプトゼミ",
            children: [
                { name: "詳細 1-1" },
                { name: "詳細 1-2" },
                { name: "詳細 1-3" },
                { name: "詳細 1-4" }
            ]
        },
        {
            name: "WEBマーケティングゼミ",
            children: [
                { name: "「作って終わり」ではない！ビジネスを成長させるウェブサイト運営の全技術" },
                { name: "「GA4と広告」連携 超入門セミナー" },
                { name: "LLMO × SEO" },
                { name: "「GA4と広告」連携 超入門セミナー" },
                { name: "【GEMINI x GA4】勘から確信へ！WEBマーケティング業務効率化ゼミ" },
                { name: "「GA4と広告」連携 超入門セミナー" },
                { name: "「GA4と広告」連携 超入門セミナー" },
                { name: "第一回WEBマーケティング（広告）ゼミ" },
                { name: "第2回：【デモ中心】検索キャンペーンを作成しよう" },
                { name: "Google広告UIゼミ" },
                { name: "「GA4と広告」連携 超入門セミナー" },
                { name: "「GA4と広告」連携 超入門セミナー" },
                { name: "Webマーケティング全体像とSNSの役割" }
            ]
        },
        {
            name: "Gemini業務効率化ゼミ",
            children: [
                { name: "詳細 1-1" },
                { name: "詳細 1-2" },
                { name: "詳細 1-3" },
                { name: "詳細 1-4" }
            ]
        },
        {
            name: "DB関連ゼミ",
            children: [
                { name: "詳細 2-1" },
                { name: "詳細 2-2" }
            ]
        },
        {
            name: "pythonゼミ",
            children: [
                { name: "詳細 1-1" },
                { name: "詳細 1-2" },
                { name: "詳細 1-3" },
                { name: "詳細 1-4" }
            ]
        },
        {
        
            name: "ゼミ数学ゼミ",
            children: [
                { name: "詳細 1-1" },
                { name: "詳細 1-2" },
                { name: "詳細 1-3" },
                { name: "詳細 1-4" }
            ]
        },
        {
            name: "アイデア 2",
            children: [
                { name: "詳細 2-1" },
                { name: "詳細 2-2" }
            ]
        },
        {
           name: "アイデア 2",
            children: [
                { name: "詳細 2-1" },
                { name: "詳細 2-2" }
            ]
        },
        {
            name: "アイデア 3",
            children: [
                { name: "詳細 3-1" }
            ]
        },
	{
            name: "検索エンジン",
            children: [
                { name: "Google", url: "https://www.google.com" },
                { name: "Yahoo! Japan", url: "https://www.yahoo.co.jp" }
            ]
        },
        {
            name: "開発リソース",
            children: [
                { name: "D3.js 公式", url: "https://d3js.org/" },
                { name: "MDN Web Docs", url: "https://developer.mozilla.org/" }
            ]
        },
        {
            name: "その他",
            children: [
                { name: "リンクなしのメモ" }
            ]
        }

    ]
};

//------------------------------------
// SVGセットアップ
//------------------------------------
const margin = {top: 20, right: 20, bottom: 20, left: 20};
let i = 0;

const svg = d3.select("body")
    .append("svg")
    .attr("width", window.innerWidth)
    .attr("height", window.innerHeight);

const g = svg.append("g")
    .attr("transform", `translate(${window.innerWidth/2},${window.innerHeight/2})`);

const linkGroup = g.append("g").attr("class", "links-layer");
const nodeGroup = g.append("g").attr("class", "nodes-layer");

const tree = d3.tree()
    .nodeSize([60, 220]); 

const linkGenerator = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);

let root = d3.hierarchy(treeData);
root.x0 = 0;
root.y0 = 0;

//------------------------------------
// ★変更点: 初期状態でルートのみにする処理
//------------------------------------
if (root.children) {
    // 1. まず子孫ノードを再帰的に閉じる
    //    (これをしないと、ルートを開いた瞬間に孫まで全開になる可能性があるため)
    root.children.forEach(collapse);

    // 2. 最後にルート自身の子も隠して、ルート1個の状態にする
    collapse(root);
}

update(root);

window.addEventListener('resize', () => {
    update(root);
});

// 再帰的に閉じる関数（自分自身の子を隠す）
function collapse(d) {
    if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
    }
}

function getTextWidth(text) {
    let len = 0;
    for (let i = 0; i < text.length; i++) {
        len += (text.charCodeAt(i) > 255) ? 14 : 9;
    }
    return len + 30; 
}

//------------------------------------
// 描画更新
//------------------------------------
function update(source) {
    const treeLayout = tree(root);
    const nodes = treeLayout.descendants();
    const links = treeLayout.links();

    nodes.forEach(d => { d.y = d.depth * 220; });

    // サイズ計算とスクロール制御
    let minX = Infinity, maxX = -Infinity; 
    let minY = Infinity, maxY = -Infinity; 

    nodes.forEach(d => {
        const w = getTextWidth(d.data.name);
        const nodeLeft = d.y - w / 2;
        const nodeRight = d.y + w / 2;
        const nodeTop = d.x - 17;
        const nodeBottom = d.x + 17;

        if (nodeLeft < minX) minX = nodeLeft;
        if (nodeRight > maxX) maxX = nodeRight;
        if (nodeTop < minY) minY = nodeTop;
        if (nodeBottom > maxY) maxY = nodeBottom;
    });

    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    const winWidth = window.innerWidth;
    const winHeight = window.innerHeight;
    const padding = 60; 

    const newSvgWidth = Math.max(winWidth, contentWidth + padding * 2);
    const newSvgHeight = Math.max(winHeight, contentHeight + padding * 2);

    svg.transition().duration(500)
        .attr("width", newSvgWidth)
        .attr("height", newSvgHeight);

    let tx, ty;

    if (newSvgWidth > winWidth) {
        tx = -minX + padding;
    } else {
        tx = (winWidth - contentWidth) / 2 - minX;
    }

    if (newSvgHeight > winHeight) {
        ty = -minY + padding;
    } else {
        ty = (winHeight - contentHeight) / 2 - minY;
    }

    g.transition()
        .duration(500)
        .attr("transform", `translate(${tx},${ty})`);

    //------------------------------------
    // ノード描画
    //------------------------------------
    const node = nodeGroup.selectAll("g.node")
        .data(nodes, d => d.id || (d.id = ++i));

    const nodeEnter = node.enter()
        .append("g")
        .attr("class", d => {
            let classes = "node";
            if (d.children || d._children) classes += " node--internal"; // _childrenも含めて内部ノード判定
            else classes += " node--leaf";
            
            if (d.depth === 0) classes += " node--root";
            if (d.data.url) classes += " node--link";
            return classes;
        })
        .attr("transform", d => `translate(${source.y0},${source.x0})`)
        .on("click", (e, d) => {
            if (d.data.url) {
                window.open(d.data.url, '_blank');
                return; 
            }

            // 子要素の開閉処理
            if (d.children || d._children) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    d._children = null;
                }
                update(d);
            }
        });

    nodeEnter.append("rect")
        .attr("rx", 6)
        .attr("ry", 6)
        .attr("width", 0)
        .attr("height", 34)
        .attr("y", -17)
        .attr("x", 0);

    nodeEnter.append("text")
        .attr("dy", "0.35em")
        .attr("x", 0)
        .attr("text-anchor", "middle")
        .text(d => d.data.name)
        .style("fill-opacity", 0);

    const nodeUpdate = nodeEnter.merge(node);

    nodeUpdate.transition()
        .duration(500)
        .attr("transform", d => `translate(${d.y},${d.x})`);

    nodeUpdate.select("rect")
        .transition()
        .duration(500)
        .attr("width", d => getTextWidth(d.data.name))
        .attr("x", d => -getTextWidth(d.data.name) / 2)
        .style("fill", d => {
            if (d.depth === 0) return "#4A90E2";
            if (d.data.url) return "#f0f8ff";
            // 子孫を持っているか、折りたたんでいる子孫がいる場合
            return (d.children || d._children) ? "#e6f2ff" : "#fff";
        })
        .style("stroke", d => d.data.url ? "#0066cc" : "#4A90E2");

    nodeUpdate.select("text")
        .transition()
        .duration(500)
        .style("fill-opacity", 1)
        .style("fill", d => {
            if (d.depth === 0) return "#fff";
            if (d.data.url) return "#0066cc";
            return "#333";
        })
        .style("text-decoration", d => d.data.url ? "underline" : "none");

    const nodeExit = node.exit().transition()
        .duration(500)
        .attr("transform", d => `translate(${source.y},${source.x})`)
        .remove();

    nodeExit.select("rect")
        .attr("width", 0)
        .attr("x", 0);

    nodeExit.select("text")
        .style("fill-opacity", 0);

    //------------------------------------
    // リンク描画
    //------------------------------------
    const link = linkGroup.selectAll("path.link")
        .data(links, d => d.target.id);

    const linkEnter = link.enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d => linkGenerator({ source: source, target: source }));

    linkEnter.merge(link).transition()
        .duration(500)
        .attr("d", linkGenerator)
        .style("stroke", d => d.source.depth === 0 ? "#4A90E2" : "#bbb");

    link.exit().transition()
        .duration(500)
        .attr("d", d => linkGenerator({ source: source, target: source }))
        .remove();

    nodes.forEach(d => {
        d.x0 = d.x;
        d.y0 = d.y;
    });
}
</script>

</body>
</html>